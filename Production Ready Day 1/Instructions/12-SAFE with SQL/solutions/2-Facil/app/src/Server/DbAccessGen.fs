// Edit or remove this or the below line to regenerate on next build
// Hash: 805b498161c71520b2511810359a41a73a67cdf12a6f1b7ceb0299fc57e58e93

//////////////////////////////////////////
//
// THIS FILE IS AUTOMATICALLY GENERATED
//
// Facil 1.4.3
//
//////////////////////////////////////////

module DbGen

#nowarn "49"

open System
open System.ComponentModel
open System.Data
open System.Threading
open Microsoft.Data.SqlClient
open Microsoft.Data.SqlClient.Server
open Facil.Runtime.CSharp
open Facil.Runtime.GeneratedCodeUtils


[<EditorBrowsable(EditorBrowsableState.Never)>]
type InternalUseOnly = private | InternalUseOnly
[<EditorBrowsable(EditorBrowsableState.Never)>]
let internalUseOnlyValue = InternalUseOnly


module TableDtos =


  module ``dbo`` =


    type ``todos`` =
      {
        ``TodoId``: Guid
        ``Description``: string
        ``AssigneeId``: Guid option
        ``Status``: string
        ``Weekly``: string option
        ``Custom``: DateTime option
      }

      static member getPrimaryKey (dto: ``todos``) =
        dto.``TodoId``


    type ``users`` =
      {
        ``UserId``: Guid
        ``Name``: string
      }

      static member getPrimaryKey (dto: ``users``) =
        dto.``UserId``


module Scripts =


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``todos_ById_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- todos_ById
SELECT
  [TodoId],
  [Description],
  [AssigneeId],
  [Status],
  [Weekly],
  [Custom]
FROM
  [dbo].[todos]
WHERE
  [TodoId] = @todoId"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_TodoId`` = 0
    let mutable ``ordinal_Description`` = 0
    let mutable ``ordinal_AssigneeId`` = 0
    let mutable ``ordinal_Status`` = 0
    let mutable ``ordinal_Weekly`` = 0
    let mutable ``ordinal_Custom`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_TodoId`` <- reader.GetOrdinal "TodoId"
      ``ordinal_Description`` <- reader.GetOrdinal "Description"
      ``ordinal_AssigneeId`` <- reader.GetOrdinal "AssigneeId"
      ``ordinal_Status`` <- reader.GetOrdinal "Status"
      ``ordinal_Weekly`` <- reader.GetOrdinal "Weekly"
      ``ordinal_Custom`` <- reader.GetOrdinal "Custom"

    let getItem (reader: SqlDataReader) : TableDtos.dbo.todos =
      let ``TodoId`` = reader.GetGuid ``ordinal_TodoId``
      let ``Description`` = reader.GetString ``ordinal_Description``
      let ``AssigneeId`` = if reader.IsDBNull ``ordinal_AssigneeId`` then None else reader.GetGuid ``ordinal_AssigneeId`` |> Some
      let ``Status`` = reader.GetString ``ordinal_Status``
      let ``Weekly`` = if reader.IsDBNull ``ordinal_Weekly`` then None else reader.GetString ``ordinal_Weekly`` |> Some
      let ``Custom`` = if reader.IsDBNull ``ordinal_Custom`` then None else reader.GetDateTime ``ordinal_Custom`` |> Some
      {
        ``TodoId`` = ``TodoId``
        ``Description`` = ``Description``
        ``AssigneeId`` = ``AssigneeId``
        ``Status`` = ``Status``
        ``Weekly`` = ``Weekly``
        ``Custom`` = ``Custom``
      }

    member __.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member __.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member __.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

    member __.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member __.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    #endif

    member __.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member __.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member __.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData


  type ``todos_ById`` private (connStr: string, conn: SqlConnection) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``todos_ById``(null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``todos_ById``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection) = ``todos_ById``(null, connection)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``todoId``: Guid
      ) =
      let getSqlParams () =
        [|
          SqlParameter("todoId", SqlDbType.UniqueIdentifier, Value = ``todoId``)
        |]
      ``todos_ById_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [])

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("todoId", SqlDbType.UniqueIdentifier, Value = (^a: (member ``TodoId``: Guid) dto))
        |]
      ``todos_ById_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [])


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``todos_Delete_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- todos_Delete
DELETE FROM [dbo].[todos]
WHERE
  [TodoId] = @todoId"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member __.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member __.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn configureConn (configureCmd sqlParams) tempTableData


  type ``todos_Delete`` private (connStr: string, conn: SqlConnection) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``todos_Delete``(null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``todos_Delete``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection) = ``todos_Delete``(null, connection)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``todoId``: Guid
      ) =
      let getSqlParams () =
        [|
          SqlParameter("todoId", SqlDbType.UniqueIdentifier, Value = ``todoId``)
        |]
      ``todos_Delete_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [])

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("todoId", SqlDbType.UniqueIdentifier, Value = (^a: (member ``TodoId``: Guid) dto))
        |]
      ``todos_Delete_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [])


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``todos_Insert_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- todos_Insert
INSERT INTO [dbo].[todos]
(
  [TodoId],
  [Description],
  [AssigneeId],
  [Status],
  [Weekly],
  [Custom]
)
VALUES
(
  @todoId,
  @description,
  @assigneeId,
  @status,
  @weekly,
  @custom
)"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member __.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member __.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn configureConn (configureCmd sqlParams) tempTableData


  type ``todos_Insert`` private (connStr: string, conn: SqlConnection) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``todos_Insert``(null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``todos_Insert``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection) = ``todos_Insert``(null, connection)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``todoId``: Guid,
        ``description``: string,
        ``assigneeId``: Guid option,
        ``status``: string,
        ``weekly``: string option,
        ``custom``: DateTime option
      ) =
      let getSqlParams () =
        [|
          SqlParameter("todoId", SqlDbType.UniqueIdentifier, Value = ``todoId``)
          SqlParameter("description", SqlDbType.NVarChar, Size = 50, Value = ``description``)
          SqlParameter("assigneeId", SqlDbType.UniqueIdentifier, Value = Option.toDbNull ``assigneeId``)
          SqlParameter("status", SqlDbType.NVarChar, Size = 50, Value = ``status``)
          SqlParameter("weekly", SqlDbType.NVarChar, Size = 10, Value = Option.toDbNull ``weekly``)
          SqlParameter("custom", SqlDbType.DateTime2, Size = 8, Value = Option.toDbNull ``custom``)
        |]
      ``todos_Insert_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [])

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("todoId", SqlDbType.UniqueIdentifier, Value = (^a: (member ``TodoId``: Guid) dto))
          SqlParameter("description", SqlDbType.NVarChar, Size = 50, Value = (^a: (member ``Description``: string) dto))
          SqlParameter("assigneeId", SqlDbType.UniqueIdentifier, Value = Option.toDbNull (^a: (member ``AssigneeId``: Guid option) dto))
          SqlParameter("status", SqlDbType.NVarChar, Size = 50, Value = (^a: (member ``Status``: string) dto))
          SqlParameter("weekly", SqlDbType.NVarChar, Size = 10, Value = Option.toDbNull (^a: (member ``Weekly``: string option) dto))
          SqlParameter("custom", SqlDbType.DateTime2, Size = 8, Value = Option.toDbNull (^a: (member ``Custom``: DateTime option) dto))
        |]
      ``todos_Insert_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [])


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``todos_Update_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- todos_Update
UPDATE
  [dbo].[todos]
SET
  [Description] = @description,
  [AssigneeId] = @assigneeId,
  [Status] = @status,
  [Weekly] = @weekly,
  [Custom] = @custom
WHERE
  [TodoId] = @todoId"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member __.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member __.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn configureConn (configureCmd sqlParams) tempTableData


  type ``todos_Update`` private (connStr: string, conn: SqlConnection) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``todos_Update``(null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``todos_Update``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection) = ``todos_Update``(null, connection)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``todoId``: Guid,
        ``description``: string,
        ``assigneeId``: Guid option,
        ``status``: string,
        ``weekly``: string option,
        ``custom``: DateTime option
      ) =
      let getSqlParams () =
        [|
          SqlParameter("todoId", SqlDbType.UniqueIdentifier, Value = ``todoId``)
          SqlParameter("description", SqlDbType.NVarChar, Size = 50, Value = ``description``)
          SqlParameter("assigneeId", SqlDbType.UniqueIdentifier, Value = Option.toDbNull ``assigneeId``)
          SqlParameter("status", SqlDbType.NVarChar, Size = 50, Value = ``status``)
          SqlParameter("weekly", SqlDbType.NVarChar, Size = 10, Value = Option.toDbNull ``weekly``)
          SqlParameter("custom", SqlDbType.DateTime2, Size = 8, Value = Option.toDbNull ``custom``)
        |]
      ``todos_Update_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [])

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("todoId", SqlDbType.UniqueIdentifier, Value = (^a: (member ``TodoId``: Guid) dto))
          SqlParameter("description", SqlDbType.NVarChar, Size = 50, Value = (^a: (member ``Description``: string) dto))
          SqlParameter("assigneeId", SqlDbType.UniqueIdentifier, Value = Option.toDbNull (^a: (member ``AssigneeId``: Guid option) dto))
          SqlParameter("status", SqlDbType.NVarChar, Size = 50, Value = (^a: (member ``Status``: string) dto))
          SqlParameter("weekly", SqlDbType.NVarChar, Size = 10, Value = Option.toDbNull (^a: (member ``Weekly``: string option) dto))
          SqlParameter("custom", SqlDbType.DateTime2, Size = 8, Value = Option.toDbNull (^a: (member ``Custom``: DateTime option) dto))
        |]
      ``todos_Update_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [])


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``users_ById_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- users_ById
SELECT
  [UserId],
  [Name]
FROM
  [dbo].[users]
WHERE
  [UserId] = @userId"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_UserId`` = 0
    let mutable ``ordinal_Name`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_UserId`` <- reader.GetOrdinal "UserId"
      ``ordinal_Name`` <- reader.GetOrdinal "Name"

    let getItem (reader: SqlDataReader) : TableDtos.dbo.users =
      let ``UserId`` = reader.GetGuid ``ordinal_UserId``
      let ``Name`` = reader.GetString ``ordinal_Name``
      {
        ``UserId`` = ``UserId``
        ``Name`` = ``Name``
      }

    member __.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member __.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member __.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

    member __.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member __.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    #endif

    member __.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member __.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member __.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData


  type ``users_ById`` private (connStr: string, conn: SqlConnection) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``users_ById``(null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``users_ById``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection) = ``users_ById``(null, connection)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``userId``: Guid
      ) =
      let getSqlParams () =
        [|
          SqlParameter("userId", SqlDbType.UniqueIdentifier, Value = ``userId``)
        |]
      ``users_ById_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [])

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("userId", SqlDbType.UniqueIdentifier, Value = (^a: (member ``UserId``: Guid) dto))
        |]
      ``users_ById_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [])


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``users_Delete_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- users_Delete
DELETE FROM [dbo].[users]
WHERE
  [UserId] = @userId"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member __.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member __.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn configureConn (configureCmd sqlParams) tempTableData


  type ``users_Delete`` private (connStr: string, conn: SqlConnection) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``users_Delete``(null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``users_Delete``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection) = ``users_Delete``(null, connection)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``userId``: Guid
      ) =
      let getSqlParams () =
        [|
          SqlParameter("userId", SqlDbType.UniqueIdentifier, Value = ``userId``)
        |]
      ``users_Delete_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [])

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("userId", SqlDbType.UniqueIdentifier, Value = (^a: (member ``UserId``: Guid) dto))
        |]
      ``users_Delete_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [])


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``users_Insert_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- users_Insert
INSERT INTO [dbo].[users]
(
  [UserId],
  [Name]
)
VALUES
(
  @userId,
  @name
)"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member __.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member __.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn configureConn (configureCmd sqlParams) tempTableData


  type ``users_Insert`` private (connStr: string, conn: SqlConnection) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``users_Insert``(null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``users_Insert``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection) = ``users_Insert``(null, connection)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``userId``: Guid,
        ``name``: string
      ) =
      let getSqlParams () =
        [|
          SqlParameter("userId", SqlDbType.UniqueIdentifier, Value = ``userId``)
          SqlParameter("name", SqlDbType.NVarChar, Size = 50, Value = ``name``)
        |]
      ``users_Insert_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [])

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("userId", SqlDbType.UniqueIdentifier, Value = (^a: (member ``UserId``: Guid) dto))
          SqlParameter("name", SqlDbType.NVarChar, Size = 50, Value = (^a: (member ``Name``: string) dto))
        |]
      ``users_Insert_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [])


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``users_Update_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- users_Update
UPDATE
  [dbo].[users]
SET
  [Name] = @name
WHERE
  [UserId] = @userId"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member __.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member __.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn configureConn (configureCmd sqlParams) tempTableData


  type ``users_Update`` private (connStr: string, conn: SqlConnection) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``users_Update``(null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``users_Update``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection) = ``users_Update``(null, connection)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``userId``: Guid,
        ``name``: string
      ) =
      let getSqlParams () =
        [|
          SqlParameter("userId", SqlDbType.UniqueIdentifier, Value = ``userId``)
          SqlParameter("name", SqlDbType.NVarChar, Size = 50, Value = ``name``)
        |]
      ``users_Update_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [])

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("userId", SqlDbType.UniqueIdentifier, Value = (^a: (member ``UserId``: Guid) dto))
          SqlParameter("name", SqlDbType.NVarChar, Size = 50, Value = (^a: (member ``Name``: string) dto))
        |]
      ``users_Update_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [])
